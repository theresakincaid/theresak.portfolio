# Theresa Kincaid's ePortfolio

#### Table of Contents:
1. Professional Self-Assessment
2. Software Design and Engineering
3. Algorithm and Data Structures
4. Database
5. Code Review

## 1. Professional Self-Assessment

## 2. Category One: Software Design and Engineering
This artifact is a Java application called “SlideShow” and was originally created in the course CS-250. It started as a slideshow with six slides and two navigation buttons, “Previous” and “Next”. The slides show various wellness related locations, each with an image and a brief description.

I have chosen to include this artifact in my ePortfolio for the software design and engineering category for the following reasons: First, it serves as evidence of my accomplishment of the course outcome, "Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science”. This code is valuable because it provides a visually appealing and interactive way for users to explore different wellness destinations. It accomplishes industry-specific goals related to creating engaging presentations and displaying information to users. The modular design of the code, the naming conventions, and the event-driven architecture all align with industry best practices. Additionally, the program follows a structured approach with well-defined methods and classes. This demonstrates my ability to organize code logically and modularize functionality.

To improve the application, I incorporated two additional buttons and implemented a timer. The first button, labeled “Restart,” allows the user to go back to the first slide and restart the slideshow from the beginning. The second button, labeled “Pause/Resume,” provides the user with the ability to pause and resume the automatic slideshow progression. When the user clicks the button, it pauses the timer and stops the automatic slide transition. Clicking the button again resumes the slideshow. The text for this button dynamically adjusts according to the state of the timer. The timer implementation adds a time interval of 3 seconds between each slide transition, providing a consistent progression through the slides. Together, these improvements create a more interactive and user-friendly experience, offering greater control over the slideshow navigation.

Overall, my experience with making these changes to the artifact was relatively trouble-free. The most demanding aspect of the enhancement was implementing the timer. While understanding the logic of the timer was easy, ensuring that the timer coordinated effectively with the card layout and slide transitions took more time. Nevertheless, I am glad I was able to implement a timer because now the slideshow successfully runs automatically.

## 3. Category Two: Algorithm and Data Structures
This artifact is a Java application named "PeopleWeights" that allows users to manage a list of people's names and their corresponding weights. It also displays useful statistics regarding those weights. This artifact was originally created as part of the IT-145 course.

I included this artifact in my ePortfolio because it fulfills the course outcome of designing and evaluating computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while effectively managing trade-offs involved in design choices. First, the code utilizes algorithmic principles, such as bubble sort for sorting the weights array and calculating the standard deviation. It also uses iterative loops and conditional statements to perform tasks based on user input. For computer science practices, the code follows standard practices of organizing code into functions and modularizing the solution. It uses appropriate naming conventions, formatting standards, and includes comments to improve code readability. The code manages trade-offs involved in design by considering factors such as time complexity, space complexity, and code efficiency. For instance, I chose the bubble sort algorithm for simplicity. Bubble sort algorithms are effective for sorting smaller data sets. However, if the data set were larger, I would have used an algorithm that prioritizes time complexity.

The first version of the program prompted the user to enter the names and weights of five people, calculated the total weight, average, and maximum, and then displayed the results. Expanding on this existing functionality, I have enhanced and refined this artifact. I added a menu that presents users with a range of options. This allows users to choose between displaying all records, entering a new record, searching for a record, and quitting the program. This menu-driven approach provides a structured workflow for managing the data. To improve the presentation of data, I implemented an algorithm to sort the weights in ascending order. This ensures that the records are displayed in a more organized manner. By incorporating sorting, users can observe the progression of weights. Lastly, I included the calculation of the standard deviation. This statistical measure provides insights into the distribution of weights. With the inclusion of menu options, sorting, and standard deviation calculation, the program now delivers more value.

When reflecting on the process of enhancing this artifact, I am pleased to say that it was a generally smooth journey. The implementation of the standard deviation calculation was the most intricate aspect of the enhancement. The standard deviation calculation involves multiple steps and requires an understanding of statistical concepts. I am satisfied that I managed to implement this calculation because it adds complexity to the program that goes beyond simple, straightforward calculations like total, average, or maximum.

## 4. Category Three: Database

## 5. Code Review

I have achieved one of the course outcomes by creating a comprehensive code review and sharing it on YouTube. This code review demonstrates my ability to design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and tailored to specific audiences and contexts. For each artifact, I covered the existing functionality, reviewed the code structure, comments, and explained the planned enhancements, highlighting their benefits and impact. The code review link can be found below.

[Click to Watch Code Review](https://youtu.be/WvT-Tb2NSYo)
